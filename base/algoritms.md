# Алгоритмы сортировки
## Теория
### BubbleSort (сортировка пузырьком)
Сортировка пузырьком — это один из самых простых, а также самых медленных способов сортировки массива, в котором 
обычно происходит много swap-операций.

Суть алгоритма заключается в следующем: в массиве, который необходимо отсортировать последовательно, попарно 
сравниваются соседние элементы, и если порядок неверный, то элементы меняются местами. Это действие нужно повторить
n-1 раз, где n — это длина исходного массива.

Сложность алогритма:
- В лучшем случае *O*(*n*).
- В среднем случае *O*(*n*2).
- В худшем случае *O*(*n*2)

### SelectionSort (сортировка выбором)
Сортировка выбором — одна из самых простых сортировок, а также, наверное, одна из самых интуитивно понятных. 
В отличие от сортировки пузырьком, в процессе ее работы требуется меньшее количество swap-операций.

Пусть у нас есть массив из *n* элементов, который необходимо отсортировать.

1. Найдём минимальный элемент в этом массиве и поставим его на первое место.
2. Повторим действие 1 для подмассива **array\[1:n\]** (для среза массива, который содержит все элементы 
исходного массива, кроме первого).

Повторяем до тех пор, пока не останется подмассив из одного элемента.

Алгоритм можно улучшить, сделав его двунаправленным. Если в случае однонаправленного вы искали только минимальное 
(максимальное) и перемещали его в начало (конец) массива, то в случае двунаправленной сортировки выбором вы ищите 
одновременно и максимальное, и минимальное число и перемещаете их в конец и начало соответственно. Это потребует 
ровно в два раза меньше итераций во внутреннем цикле.

Сложность алогритма:
- В лучшем случае *O*(*n*2).
- В среднем случае *O*(*n*2).
- В худшем случае *O*(*n*2).
```python
def selection_sort(arr):
    n = len(arr)
    
    # Проходим по всем элементам массива
    for i in range(n):
        # Ищем минимальный элемент в неотсортированной части массива
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Меняем местами минимальный элемент с первым элементом неотсортированной части
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr
```

### InsertionSort (сортировка вставками)
Сортировка вставками — один из самых простых сортировок, которая используется в большинстве практических приложений. 
В отличие от сортировки пузырьком, в процессе ее работы требуется меньшее количество swap-операций.

Суть его заключается в следующем:

Мы перебираем все элементы, начиная с первого, и проверяем, есть ли слева от него элементы большие, чем он сам. 
Если есть, то перемещаем элемент левее. И так до тех пор, пока он не встанет на нужное место.

Как и с предыдущими алгоритмами, если нас интересует обратный порядок сортировки, то мы просто меняем знак сравнения 
(«больше» на «меньше»).

Таким образом, во время вашей итерации слева всегда будет отсортированный массив (подмассив), а элементы справа 
вы по очереди проверяете и ставите на свое место в подмассиве слева.

```python
def insertionSort(a: []): 
    for i in range(1, len(a)):
        c = a[i]
        j = i-1
        
        while j >= 0 and c < a[j]:
            a[j+1] = a[j]
            j -= 1
        
        a[j+1] = c
```

Сложность алогритма:
- В лучшем случае *O*(*n*).
- В среднем случае *O*(*n*2).
- В худшем случае *O*(*n*2).

### MergeSort (сортировка слиянием)
**Сортировка слиянием** — это интересный алгоритм, так как он одинаково быстро работает на любых входных данных 
(и в худшем и в лучшем случае), но требует дополнительных затрат по памяти. Также является отличным примером одной 
из популярнейших парадигм в программировании: **разделяй и властвуй**.

Суть сортировки слиянием заключается в следующем:
- Делим массив на два подмассива.
- Сортируем подмассивы*.
- Совершаем слияние полученных отсортированных массивов.

*\*Хитрость заключается в том, что подмассивы сортируются всётой же сортировкой слиянием, то есть функция 
вызывается рекурсивно.*

Это действительно быстрая сортировка, которая имеет одинаковую асимптотику на любых входных данных. 
Но у него есть два недостатка:
1. Использование дополнительной памяти.
2. Рекурсивность: требуется *n* рекурсивных вызовов функции, что может вызвать ошибку переполнения стека для 
больших массивов.

Сложность алгоритма:
- В лучшем случае *O(n log(n))*
- В среднем случае *O(n log(n))*
- В худшем случае *O(n log(n))*

### QuickSort (быстрая сортировка)

Итак, алгоритм быстрой сортировки — это алгоритм из группы «прямого обмена» (как и *bubblesort*):
- Выбираем какой-то случайный элемент из массива, который необходимо отсортировать. Этот элемент будет 
называться опорным.
- Перемещаем все элементы меньшие его влево, а большие, соответственно, вправо.
- Выполняем этот же алгоритм повторно для «левой» и «правой» части алгоритма.

Главное преимущество этого алгоритма — это универсальность. Он даёт стабильно хороший результат на случайных данных, 
и за счёт этого используется повсеместно.

Сложность алгоритма:
- В лучшем случае *O(n log(n))*
- В среднем случае *O(n log(n))*
- В худшем случае *O(n2)*