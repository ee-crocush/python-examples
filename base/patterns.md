# Архитектура и паттерны проектирование

## Паттерны

### Определение

Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.

### Классификация паттернов

Паттерны отличаются по уровню сложности, детализации и охвата проектируемой системы. Проводя аналогию со строительством, вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой автомобильной развязкой с подземными переходами.

Самые низкоуровневые и простые паттерны — **идиомы**. Они не универсальны, поскольку применимы только в рамках одного языка программирования.

Самые универсальные — **архитектурные паттерны**, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.

Изначально существовало две основные классификации паттернов проектирования:

- Какую проблему решает паттерн.
- Как относится паттерн к классам или объектам.

Принимая во внимание первую классификацию, паттерны можно разделить на три группы:

- **Порождающие** – предоставляют возможность создания контролируемым образом, инициализации и конфигурации объектов, классов и типов данных на основе требуемых критериев.
- **Структурные** – помогают организовать структуры связанных объектов и классов, предоставляя новые функциональные возможности.
- **Поведенческие** – направлены на выявление общих моделей взаимодействия между объектами.
  Позже появились новые паттерны проектирования, из которых можно выделить еще одну категорию:
- **Concurrency (параллелизм)** – это тот тип паттернов проектирования, который имеет дело с многопоточной парадигмой программирования.

### Примеры паттернов

#### Паттерн 1: Синглтон

Синглтон (одиночка) – это паттерн проектирования, цель которого ограничить возможность создания объектов данного класса одним экземпляром. Он обеспечивает глобальность до одного экземпляра и глобальный доступ к созданному объекту.

##### Примеры использования

Класс в вашей программе имеет только один экземпляр, доступный всем клиентам. Например, один объект базы данных, разделяемый различными частями программы.
В случае если вам необходим более строгий контроль над глобальными переменными.

```python
class Logger:
   @staticmethod
   def get_instance():
       if '_instance' not in Logger.__dict__:
           Logger._instance = Logger()
       return Logger._instance

   def write_log(self, path):
       pass


if __name__ == "__main__":
   s1 = Logger.get_instance()
   s2 = Logger.get_instance()
   assert s1 is s2
```

Возможно ли найти более оптимальный способ (без наследования классов)?

```python
class Singleton(type):
  _instances = {}
  def __call__(cls, *args, **kwargs):
      if cls not in cls._instances:
          instance = super().__call__(*args, **kwargs)
          cls._instances[cls] = instance
      return cls._instances[cls]
class Logger(metaclass=Singleton):
  def write_log(self, path):
      pass
if __name__ == "__main__":
  logger1 = Logger()
  logger2 = Logger()
  assert logger1 is logger2
```

Все работает. Однако, надо сделать еще одну настройку – подготовить программу к работе в многопоточной среде.

```python
from threading import Lock, Thread
class Singleton(type):
  _instances = {}
  _lock: Lock = Lock()
  def __call__(cls, *args, **kwargs):
      with cls._lock:
          if cls not in cls._instances:
              instance = super().__call__(*args, **kwargs)
              cls._instances[cls] = instance
      return cls._instances[cls]
class Logger(metaclass=Singleton):
  def __init__(self, name):
      self.name = name
  def write_log(self, path):
      pass
def test_logger(name):
  logger = Logger(name)
  print(logger.name)
if __name__ == "__main__":
  process1 = Thread(target=test_logger, args=("FOO",))
  process2 = Thread(target=test_logger, args=("BAR",))
  process1.start()
  process2.start()
```

##### Подведем итоги. Особенности использования Синглтона

- Класс имеет только один экземпляр;
- Вы получаете глобальную точку доступа к этому экземпляру;
- Синглтон инициализируется только при первом запросе;
- Маскирует плохой дизайн до определенного момента. Это одна из причин, почему многие считают синглтон антипаттерном.

#### Паттерн 2: Декоратор

Декоратор – это структурный паттерн. Цель которого – предоставление новых функциональных возможностей классам и объектам во время выполнения кода.

Чаще всего декоратор представляет собой абстрактный класс, принимающий в конструкторе объект, функциональность которого мы хотим расширить. Но в Python есть и встроенный механизм декораторов, который можно использовать.

##### Случаи использования

- Необходимость назначить дополнительные обязанности объектам во время выполнения, не ломая код, который использует эти объекты;
- По каким-то причинам невозможно расширить «цепочку обязанностей» объекта через наследование.

##### Пример кода

Используя декораторы, вы можете обернуть объекты несколько раз, поскольку и цель, и декораторы реализуют один и тот же интерфейс.

Получаемый объект будет обладать объединенной и сложенной функциональностью всех декораторов.

```python
from abc import ABC, abstractmethod

class Component(ABC):
  @abstractmethod
  def operation(self):
      pass


class ConcreteComponent(Component):
  def operation(self):
      return "ConcreteComponent"


class Decorator(Component):
  def __init__(self, component):
      self.component = component

  @abstractmethod
  def operation(self):
      pass


class ConcreteDecoratorA(Decorator):
  def operation(self):
      return f"ConcreteDecoratorA({self.component.operation()})"


class ConcreteDecoratorB(Decorator):
  def operation(self):
      return f"ConcreteDecoratorB({self.component.operation()})"


if __name__ == "__main__":
  concreteComponent = ConcreteComponent()
  print(concreteComponent.operation())
  decoratorA = ConcreteDecoratorA(concreteComponent)
  decoratorB = ConcreteDecoratorB(decoratorA)
  print(decoratorB.operation())

```

Практичный пример с использованием встроенного механизма декораторов:

```python
import sys

def memoize(f):
  cache = dict()
  def wrapper(x):
      if x not in cache:
          cache[x] = f(x)
      return cache[x]
  return wrapper

@memoize
def fib(n):
  if n <= 1:
      return n
  else:
      return fib(n - 1) + fib(n - 2)

if __name__ == "__main__":
  sys.setrecursionlimit(2000)
  print(fib(750))
```

Без использования декоратора кэша для функции, которая рекурсивно вычисляет n-й член ряда Фибоначчи, трудно вычислить результат для значения 100 за все время работы.

##### Подведем итоги.

- Расширение поведения объекта без создания подкласса;
- Добавление или удаление обязанности объекта во время выполнения;
- Объединение нескольких моделей поведения, путем применения к объекту нескольких декораторов;
- Разделение монолитного класса, который реализует множество вариантов поведения на более мелкие классы.

При применении этого паттерна возникают следующие сложности:

- Применение одной конкретной обертки (wrapper) из центра стека (stack);
- Реализация декоратора, при исключении его зависимости от порядка, в котором обертки уложены в стек.

#### Паттерн 3: Итератор

Итератор – это поведенческий паттерн. Его цель – позволить вам обходить элементы коллекции, не раскрывая ее базовое представление.

Чтобы реализовать итератор в Python, у нас есть два возможных варианта:

- Реализовать в классе специальные методы \_\_iter\_\_ и \_\_next\_\_.
- Использовать генераторы.

##### Примеры использования

- Коллекция имеет сложную структуру. Необходимо скрыть ее от клиента из соображений удобства или безопасности;
- Требуется сократить дублирование обходного кода по всему приложению;
  -Обход элементов различных структур данных;
- Изначально неизвестны детали структуры данных.

##### Пример кода

Создание пользовательской коллекции с итератором алфавитного порядка:

```python
from collections.abc import Iterator, Iterable


class AlphabeticalOrderIterator(Iterator):
   _position: int = None
   _reverse: bool = False

   def __init__(self, collection, reverse=False):
       self._collection = sorted(collection)
       self._reverse = reverse
       self._position = -1 if reverse else 0

   def __next__(self):
       try:
           value = self._collection[self._position]
           self._position += -1 if self._reverse else 1
       except IndexError:
           raise StopIteration()
       return value
```

Следующий пример относится к генератору, который представляет собой особый вид функции. Функция может быть приостановлена и возобновлена с того места, где была совершена пауза. На основе сохраненного состояния можно возвращать различные значения при последующих вызовах генератора.

```python
def prime_generator():
  yield 2
  primes = [2]
  to_check = 3
  while True:
      sqrt = to_check ** 0.5
      is_prime = True
      for prime in primes:
          if prime > sqrt:
              break
          if to_check % prime == 0:
              is_prime = False
              break
      if is_prime:
          primes.append(to_check)
          yield to_check
      to_check += 2
generator = prime_generator()
print([next(generator) for _ in range(20)])
```

##### Подведем итоги. Возможности итератора

- Очистить клиентский код и коллекции, вынеся код обхода в отдельные классы;
- Реализовать новые типы коллекций и итераторов с передачей их в существующий код без нарушений;
- Обходить одну и ту же коллекцию с помощью нескольких итераторов параллельно, учитывая, что каждый из них хранит информацию о состоянии итерации;
- Возможность отложить итерацию и продолжить ее по мере необходимости.

Использование этого паттерна будет лишним, если ваше приложение работает только с простыми коллекциями. Более того, использование итератора может быть менее эффективным, чем прямой обход элементов какой-либо специализированной коллекции.

## Архитектура

### 1. Монолитная архитектура

#### Описание

- Все модули и компоненты приложения объединены в один код и исполняются как единое целое.
- Пример: классическое приложение Django.

#### Плюсы

- Простота разработки и деплоя.
- Легче отлаживать на начальных этапах.
- Нет проблем с сетевой задержкой.

#### Минусы

- **Сложность масштабирования**: весь код масштабируется как единый блок.
- **Неповоротливость**: добавление новых функций или изменение старых требует осторожности.

#### Когда применять

- Небольшие проекты или стартапы.
- Когда нужна быстрая разработка MVP (минимального жизнеспособного продукта).

### 2. Микросервисная архитектура

#### Описание

Приложение делится на независимые сервисы, каждый из которых отвечает за свою задачу (например, управление пользователями, заказы, уведомления).

#### Плюсы

- **Локализованная ответственность**: каждый сервис выполняет свою задачу.
- **Масштабируемость**: можно масштабировать только те сервисы, которые требуют ресурсов.
- **Технологическая гибкость**: разные сервисы могут использовать разные технологии.

#### Минусы

- Сложность взаимодействия между сервисами (например, gRPC или REST).
- Повышенные затраты на DevOps и мониторинг.
- Сложность согласования данных между сервисами.

#### Когда применять

- Большие проекты с высокими нагрузками.
- Разделение разработки между командами.
- Если проект будет долго развиваться и расширяться.

### 3. Событийно-ориентированная архитектура (Event-Driven Architecture)

#### Описание

Сервисы или модули взаимодействуют посредством событий, которые публикуются и обрабатываются другими частями системы.

#### Плюсы

- **Асинхронность**: модули могут работать независимо друг от друга.
- **Масштабируемость**: легко добавлять новые обработчики событий.
- **Устойчивость**: сбой одного модуля не нарушает работу других.

#### Минусы

- Сложность тестирования и отладки.
- Нужен надежный брокер сообщений (RabbitMQ, Kafka).
- Возможны задержки в обработке событий.

#### Когда применять

- Высоконагруженные системы, требующие асинхронной обработки.
- Сложные бизнес-процессы с большим количеством шагов.
- Проекты, где нужно легко добавлять новые модули.

### 4. Чистая архитектура (Clean Architecture)

#### Описание

- Приложение делится на слои, причем зависимость всегда направлена внутрь: внешний мир зависит от внутреннего, а не наоборот.
- Центральный слой — это доменная логика.

#### Плюсы

- Упрощение тестирования.
- Гибкость и адаптивность.
- Независимость от фреймворков и баз данных.

#### Минусы

- Увеличение сложности на старте.
- Трудно применять для небольших проектов.

#### Когда применять

- Долгосрочные проекты с большими требованиями к качеству кода.
- Если проект может сильно измениться в будущем.

### 5. Луковая архитектура (Onion Architecture)

#### Описание

Очень похожа на чистую архитектуру, но с четким акцентом на доменную модель в центре.

#### Плюсы

- Изоляция домена от инфраструктуры.
- Хорошо структурированная кодовая база.

#### Минусы

- Сложность начального проектирования.
- Для небольших проектов кажется "перегруженной".

#### Когда применять

- Проекты с четко выраженной доменной областью.
- Нужна долгосрочная поддержка кода.

### 6. Domain-Driven Design (DDD, предметно-ориентированное проектирование)

#### Описание

Архитектура строится вокруг доменной модели. Это больше подход к проектированию, чем конкретная архитектура, но часто используется с микросервисами.

#### Плюсы

- Фокус на бизнес-логике.
- Ясная и понятная модель домена.

#### Минусы

- Требует высокого уровня навыков у разработчиков.
- Увеличение сложности на старте.

#### Когда применять

- Сложные бизнес-домены.
- Проекты с большим количеством бизнес-правил.

### Сравнение

| Архитектура          | Простота разработки | Масштабируемость | Подходит для сложных доменов | Затраты DevOps | Независимость компонентов |
| -------------------- | ------------------- | ---------------- | ---------------------------- | -------------- | ------------------------- |
| Монолит              | +                   | -                | -                            | +              | -                         |
| Микросервисы         | -                   | +                | +                            | -              | +                         |
| Событийная           | -                   | +                | +                            | -              | +                         |
| Чистая архитектура   | -                   | +                | +                            | +/-            | +                         |
| Луковая архитектура  | -                   | +                | +                            | +/-            | +                         |
| Domain-Driven Design | -                   | +/-              | +                            | +/-            | +                         |

#### Вывод

- Если проект небольшой и требует быстрой разработки — лучше начинать с монолита.
- Для сложных, высоконагруженных систем с распределенной командой — подойдут микросервисы.
- Если важна асинхронность и гибкость — выбирай событийную архитектуру.
- Для долгосрочных проектов с акцентом на качество кода и сложный бизнес-домен — чистая архитектура или DDD.

### Сравнение слоев

| Архитектура         | Основные слои                                     | Особенности                 |
| ------------------- | ------------------------------------------------- | --------------------------- |
| Монолит             | Презентация, Бизнес-логика, Данные                | Простая структура.          |
| Микросервисы        | API, Сервис, Данные, Коммуникация                 | Изоляция между сервисами.   |
| Событийная          | Публикация, Обработка, Логика, Данные             | Асинхронное взаимодействие. |
| Чистая архитектура  | Entities, Use Cases, Adapters, Drivers            | Зависимость внутрь.         |
| Луковая архитектура | Core, Application, Infrastructure                 | Четкий акцент на домен.     |
| DDD                 | Domain, Application, Infrastructure, Presentation | Фокус на доменной модели.   |

## Дополнительно

### Как организовать проект Django, чтобы он был модульным и масштабируемым?

#### Разделение на приложения

- Каждый модуль (например, users, orders) оформляется как отдельное приложение.
- Логика конкретного модуля сосредоточена в соответствующем приложении.

#### Использование сервисного слоя

Вынос бизнес-логики в сервисы, чтобы контроллеры (views) оставались чистыми.

##### Пример

```python

# Сервис
class UserService:
    def activate_user(self, user):
        user.is_active = True
        user.save()

# View
from django.http import JsonResponse

def activate_user_view(request, user_id):
    user = User.objects.get(id=user_id)
    UserService().activate_user(user)

    return JsonResponse({"status": "success"})
```

#### Конфигурация и настройки

- Используйте settings для разделения конфигураций (например, settings/base.py, settings/production.py, settings/development.py).
- Храните секреты в .env файлах.

#### Использование DRF

- Настройка сериализаторов и ViewSet'ов упрощает разработку и поддерживаемость API.
- Разработка REST API

### Что такое идемпотентные запросы?

Идемпотентность означает, что повторное выполнение одного и того же запроса не изменяет результат.
Примеры:

- GET: Всегда идемпотентен (возвращает один и тот же результат).
- PUT: Перезаписывает ресурс целиком, но не создает новый.
- DELETE: Удаляет ресурс; повторный вызов не изменит результат.

Неидемпотентный: POST, так как при повторном вызове создает новые ресурсы.

### Какие методы HTTP считаются безопасными?

Безопасные методы: Методы, которые не изменяют состояние сервера:

- GET
- HEAD
- OPTIONS

Небезопасные методы:

POST, PUT, DELETE, так как они изменяют данные.
