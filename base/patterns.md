# Паттерны проектирование

## Определение
Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет
собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить 
под нужды вашей программы.

## Классификация паттернов
Паттерны отличаются по уровню сложности, детализации и охвата проектируемой системы. Проводя аналогию со 
строительством, вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой 
автомобильной развязкой с подземными переходами.
Самые низкоуровневые и простые паттерны — **идиомы**. Они не универсальны, поскольку применимы только в рамках одного 
языка программирования.
Самые универсальные — **архитектурные паттерны**, которые можно реализовать практически на любом языке. Они нужны для 
проектирования всей программы, а не отдельных её элементов.

Изначально существовало две основные классификации паттернов проектирования:
- Какую проблему решает паттерн.
- Как относится паттерн к классам или объектам.

Принимая во внимание первую классификацию, паттерны можно разделить на три группы:
- **Порождающие** – предоставляют возможность создания контролируемым образом, инициализации и конфигурации объектов,
- классов и типов данных на основе требуемых критериев.
- **Структурные** – помогают организовать структуры связанных объектов и классов, предоставляя новые функциональные 
возможности.
- **Поведенческие** – направлены на выявление общих моделей взаимодействия между объектами.
  Позже появились новые паттерны проектирования, из которых можно выделить еще одну категорию:
- **Concurrency (параллелизм)** – это тот тип паттернов проектирования, который имеет дело с многопоточной парадигмой 
программирования.

## Примеры паттернов

### Паттерн 1: Синглтон
Синглтон (одиночка) – это паттерн проектирования, цель которого ограничить возможность создания объектов данного класса 
одним экземпляром. Он обеспечивает глобальность до одного экземпляра и глобальный доступ к созданному объекту.

#### Примеры использования
Класс в вашей программе имеет только один экземпляр, доступный всем клиентам. Например, один объект базы данных, 
разделяемый различными частями программы.
В случае если вам необходим более строгий контроль над глобальными переменными.

```python
class Logger:
   @staticmethod
   def get_instance():
       if '_instance' not in Logger.__dict__:
           Logger._instance = Logger()
       return Logger._instance

   def write_log(self, path):
       pass


if __name__ == "__main__":
   s1 = Logger.get_instance()
   s2 = Logger.get_instance()
   assert s1 is s2
```

Возможно ли найти более оптимальный способ (без наследования классов)?

```python
class Singleton(type):
  _instances = {}
  def __call__(cls, *args, **kwargs):
      if cls not in cls._instances:
          instance = super().__call__(*args, **kwargs)
          cls._instances[cls] = instance
      return cls._instances[cls]
class Logger(metaclass=Singleton):
  def write_log(self, path):
      pass
if __name__ == "__main__":
  logger1 = Logger()
  logger2 = Logger()
  assert logger1 is logger2
```

Все работает. Однако, надо сделать еще одну настройку – подготовить программу к работе в многопоточной среде.

```python
from threading import Lock, Thread
class Singleton(type):
  _instances = {}
  _lock: Lock = Lock()
  def __call__(cls, *args, **kwargs):
      with cls._lock:
          if cls not in cls._instances:
              instance = super().__call__(*args, **kwargs)
              cls._instances[cls] = instance
      return cls._instances[cls]
class Logger(metaclass=Singleton):
  def __init__(self, name):
      self.name = name
  def write_log(self, path):
      pass
def test_logger(name):
  logger = Logger(name)
  print(logger.name)
if __name__ == "__main__":
  process1 = Thread(target=test_logger, args=("FOO",))
  process2 = Thread(target=test_logger, args=("BAR",))
  process1.start()
  process2.start()
```

#### Подведем итоги. Особенности использования Синглтона
- Класс имеет только один экземпляр;
- Вы получаете глобальную точку доступа к этому экземпляру;
- Синглтон инициализируется только при первом запросе;
- Маскирует плохой дизайн до определенного момента. Это одна из причин, почему многие считают синглтон антипаттерном.

### Паттерн 2: Декоратор
Декоратор – это структурный паттерн. Цель которого – предоставление новых функциональных возможностей классам и 
объектам во время выполнения кода.

Чаще всего декоратор представляет собой абстрактный класс, принимающий в конструкторе объект, функциональность которого 
мы хотим расширить. Но в Python есть и встроенный механизм декораторов, который можно использовать.

#### Случаи использования
- Необходимость назначить дополнительные обязанности объектам во время выполнения, не ломая код, который использует 
эти объекты;
- По каким-то причинам невозможно расширить «цепочку обязанностей» объекта через наследование.

#### Пример кода
Используя декораторы, вы можете обернуть объекты несколько раз, поскольку и цель, и декораторы реализуют один и тот 
же интерфейс.
Получаемый объект будет обладать объединенной и сложенной функциональностью всех декораторов.

```python
from abc import ABC, abstractmethod

class Component(ABC):
  @abstractmethod
  def operation(self):
      pass


class ConcreteComponent(Component):
  def operation(self):
      return "ConcreteComponent"


class Decorator(Component):
  def __init__(self, component):
      self.component = component

  @abstractmethod
  def operation(self):
      pass


class ConcreteDecoratorA(Decorator):
  def operation(self):
      return f"ConcreteDecoratorA({self.component.operation()})"


class ConcreteDecoratorB(Decorator):
  def operation(self):
      return f"ConcreteDecoratorB({self.component.operation()})"


if __name__ == "__main__":
  concreteComponent = ConcreteComponent()
  print(concreteComponent.operation())
  decoratorA = ConcreteDecoratorA(concreteComponent)
  decoratorB = ConcreteDecoratorB(decoratorA)
  print(decoratorB.operation())

```

Практичный пример с использованием встроенного механизма декораторов:

```python
import sys

def memoize(f):
  cache = dict()
  def wrapper(x):
      if x not in cache:
          cache[x] = f(x)
      return cache[x]
  return wrapper

@memoize
def fib(n):
  if n <= 1:
      return n
  else:
      return fib(n - 1) + fib(n - 2)

if __name__ == "__main__":
  sys.setrecursionlimit(2000)
  print(fib(750))
```

Без использования декоратора кэша для функции, которая рекурсивно вычисляет n-й член ряда Фибоначчи, трудно вычислить 
результат для значения 100 за все время работы.

#### Подведем итоги.
- Расширение поведения объекта без создания подкласса;
- Добавление или удаление обязанности объекта во время выполнения;
- Объединение нескольких моделей поведения, путем применения к объекту нескольких декораторов;
- Разделение монолитного класса, который реализует множество вариантов поведения на более мелкие классы.

При применении этого паттерна возникают следующие сложности:
- Применение одной конкретной обертки (wrapper) из центра стека (stack);
- Реализация декоратора, при исключении его зависимости от порядка, в котором обертки уложены в стек.

### Паттерн 3: Итератор
Итератор – это поведенческий паттерн. Его цель – позволить вам обходить элементы коллекции, не раскрывая ее базовое 
представление.

Чтобы реализовать итератор в Python, у нас есть два возможных варианта:
- Реализовать в классе специальные методы \_\_iter\_\_ и \_\_next\_\_.
- Использовать генераторы.

#### Примеры использования
- Коллекция имеет сложную структуру. Необходимо скрыть ее от клиента из соображений удобства или безопасности;
- Требуется сократить дублирование обходного кода по всему приложению;
- Обход элементов различных структур данных;
- Изначально неизвестны детали структуры данных.

#### Пример кода
Создание пользовательской коллекции с итератором алфавитного порядка:

```python
from collections.abc import Iterator, Iterable


class AlphabeticalOrderIterator(Iterator):
   _position: int = None
   _reverse: bool = False

   def __init__(self, collection, reverse=False):
       self._collection = sorted(collection)
       self._reverse = reverse
       self._position = -1 if reverse else 0

   def __next__(self):
       try:
           value = self._collection[self._position]
           self._position += -1 if self._reverse else 1
       except IndexError:
           raise StopIteration()
       return value
```

Следующий пример относится к генератору, который представляет собой особый вид функции. Функция может быть 
приостановлена и возобновлена с того места, где была совершена пауза. На основе сохраненного состояния можно возвращать 
различные значения при последующих вызовах генератора.

```python
def prime_generator():
  yield 2
  primes = [2]
  to_check = 3
  while True:
      sqrt = to_check ** 0.5
      is_prime = True
      for prime in primes:
          if prime > sqrt:
              break
          if to_check % prime == 0:
              is_prime = False
              break
      if is_prime:
          primes.append(to_check)
          yield to_check
      to_check += 2
generator = prime_generator()
print([next(generator) for _ in range(20)])
```

#### Подведем итоги. Возможности итератора
- Очистить клиентский код и коллекции, вынеся код обхода в отдельные классы;
- Реализовать новые типы коллекций и итераторов с передачей их в существующий код без нарушений;
- Обходить одну и ту же коллекцию с помощью нескольких итераторов параллельно, учитывая, что каждый из них хранит 
- информацию о состоянии итерации;
- Возможность отложить итерацию и продолжить ее по мере необходимости.

Использование этого паттерна будет лишним, если ваше приложение работает только с простыми коллекциями. Более того, 
использование итератора может быть менее эффективным, чем прямой обход элементов какой-либо специализированной 
коллекции.

### Паттерн 4. Абстрактная фабрика
Абстрактная фабрика — это порождающий паттерн проектирования, который решает проблему создания целых семейств связанных 
продуктов, без указания конкретных классов продуктов.

Абстрактная фабрика задаёт интерфейс создания всех доступных типов продуктов, а каждая конкретная реализация фабрики 
порождает продукты одной из вариаций. Клиентский код вызывает методы фабрики для получения продуктов, вместо 
самостоятельного создания с помощью оператора new. При этом фабрика сама следит за тем, чтобы создать продукт нужной 
вариации.

**Применимость**: Паттерн можно часто встретить в Python-коде, особенно там, где требуется создание семейств продуктов 
(например, внутри фреймворков).
**Признаки применения паттерна**: Паттерн можно определить по методам, возвращающим фабрику, которая, в свою очередь, 
используется для создания конкретных продуктов, возвращая их через абстрактные типы или интерфейсы.

#### Применимость
- Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от 
конкретных классов продуктов.
- Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов 
продуктов.

#### Преимущества
- Гарантирует сочетаемость создаваемых продуктов. 
- Избавляет клиентский код от привязки к конкретным классам продуктов. 
- Выделяет код производства продуктов в одно место, упрощая поддержку кода. 
- Упрощает добавление новых продуктов в программу. 
- Реализует принцип открытости/закрытости.

#### Недостатки
- Усложняет код программы из-за введения множества дополнительных классов. 
- Требует наличия всех типов продуктов в каждой вариации.

#### Пример
```python
from __future__ import annotations
from abc import ABC, abstractmethod


class AbstractFactory(ABC):
    """
    Интерфейс Абстрактной Фабрики объявляет набор методов, которые возвращают
    различные абстрактные продукты. Эти продукты называются семейством и связаны
    темой или концепцией высокого уровня. Продукты одного семейства обычно могут
    взаимодействовать между собой. Семейство продуктов может иметь несколько
    вариаций, но продукты одной вариации несовместимы с продуктами другой.
    """
    @abstractmethod
    def create_product_a(self) -> AbstractProductA:
        pass

    @abstractmethod
    def create_product_b(self) -> AbstractProductB:
        pass


class ConcreteFactory1(AbstractFactory):
    """
    Конкретная Фабрика производит семейство продуктов одной вариации. Фабрика
    гарантирует совместимость полученных продуктов. Обратите внимание, что
    сигнатуры методов Конкретной Фабрики возвращают абстрактный продукт, в то
    время как внутри метода создается экземпляр конкретного продукта.
    """

    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA1()

    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB1()


class ConcreteFactory2(AbstractFactory):
    """
    Каждая Конкретная Фабрика имеет соответствующую вариацию продукта.
    """

    def create_product_a(self) -> AbstractProductA:
        return ConcreteProductA2()

    def create_product_b(self) -> AbstractProductB:
        return ConcreteProductB2()


class AbstractProductA(ABC):
    """
    Каждый отдельный продукт семейства продуктов должен иметь базовый интерфейс.
    Все вариации продукта должны реализовывать этот интерфейс.
    """

    @abstractmethod
    def useful_function_a(self) -> str:
        pass


"""
Конкретные продукты создаются соответствующими Конкретными Фабриками.
"""


class ConcreteProductA1(AbstractProductA):
    def useful_function_a(self) -> str:
        return "The result of the product A1."


class ConcreteProductA2(AbstractProductA):
    def useful_function_a(self) -> str:
        return "The result of the product A2."


class AbstractProductB(ABC):
    """
    Базовый интерфейс другого продукта. Все продукты могут взаимодействовать
    друг с другом, но правильное взаимодействие возможно только между продуктами
    одной и той же конкретной вариации.
    """
    @abstractmethod
    def useful_function_b(self) -> None:
        """
        Продукт B способен работать самостоятельно...
        """
        pass

    @abstractmethod
    def another_useful_function_b(self, collaborator: AbstractProductA) -> None:
        """
        ...а также взаимодействовать с Продуктами A той же вариации.

        Абстрактная Фабрика гарантирует, что все продукты, которые она создает,
        имеют одинаковую вариацию и, следовательно, совместимы.
        """
        pass


"""
Конкретные Продукты создаются соответствующими Конкретными Фабриками.
"""


class ConcreteProductB1(AbstractProductB):
    def useful_function_b(self) -> str:
        return "The result of the product B1."

    """
    Продукт B1 может корректно работать только с Продуктом A1. Тем не менее, он
    принимает любой экземпляр Абстрактного Продукта А в качестве аргумента.
    """

    def another_useful_function_b(self, collaborator: AbstractProductA) -> str:
        result = collaborator.useful_function_a()
        return f"The result of the B1 collaborating with the ({result})"


class ConcreteProductB2(AbstractProductB):
    def useful_function_b(self) -> str:
        return "The result of the product B2."

    def another_useful_function_b(self, collaborator: AbstractProductA):
        """
        Продукт B2 может корректно работать только с Продуктом A2. Тем не менее
        он принимает любой экземпляр Абстрактного Продукта А в качестве
        аргумента.
        """
        result = collaborator.useful_function_a()
        return f"The result of the B2 collaborating with the ({result})"


def client_code(factory: AbstractFactory) -> None:
    """
    Клиентский код работает с фабриками и продуктами только через абстрактные
    типы: Абстрактная Фабрика и Абстрактный Продукт. Это позволяет передавать
    любой подкласс фабрики или продукта клиентскому коду, не нарушая его.
    """
    product_a = factory.create_product_a()
    product_b = factory.create_product_b()

    print(f"{product_b.useful_function_b()}")
    print(f"{product_b.another_useful_function_b(product_a)}", end="")


if __name__ == "__main__":
    """
    Клиентский код может работать с любым конкретным классом фабрики.
    """
    print("Client: Testing client code with the first factory type:")
    client_code(ConcreteFactory1())

    print("\n")

    print("Client: Testing the same client code with the second factory type:")
    client_code(ConcreteFactory2())
```

### Паттерн 5. Фабричный метод
Фабричный метод — это порождающий паттерн проектирования, который решает проблему создания различных продуктов, 
без указания конкретных классов продуктов.

Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов-продуктов. 
Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых продуктов.

**Применимость**: Паттерн можно часто встретить в любом Python-коде, где требуется гибкость при создании продуктов.
**Признаки применения паттерна**: Фабричный метод можно определить по создающим методам, которые возвращают объекты 
продуктов через абстрактные типы или интерфейсы. Это позволяет переопределять типы создаваемых продуктов в подклассах.

#### Применимость
- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
- Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
- Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.

#### Преимущества
- Избавляет класс от привязки к конкретным классам продуктов.
- Выделяет код производства продуктов в одно место, упрощая поддержку кода.
- Упрощает добавление новых продуктов в программу.
- Реализует принцип открытости/закрытости.

#### Недостатки
- Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать 
свой подкласс создателя.

#### Пример

```python
from __future__ import annotations
from abc import ABC, abstractmethod


class Creator(ABC):
    """
    Класс Создатель объявляет фабричный метод, который должен возвращать объект
    класса Продукт. Подклассы Создателя обычно предоставляют реализацию этого
    метода.
    """

    @abstractmethod
    def factory_method(self):
        """
        Обратите внимание, что Создатель может также обеспечить реализацию
        фабричного метода по умолчанию.
        """
        pass

    def some_operation(self) -> str:
        """
        Также заметьте, что, несмотря на название, основная обязанность
        Создателя не заключается в создании продуктов. Обычно он содержит
        некоторую базовую бизнес-логику, которая основана на объектах Продуктов,
        возвращаемых фабричным методом. Подклассы могут косвенно изменять эту
        бизнес-логику, переопределяя фабричный метод и возвращая из него другой
        тип продукта.
        """

        # Вызываем фабричный метод, чтобы получить объект-продукт.
        product = self.factory_method()

        # Далее, работаем с этим продуктом.
        result = f"Creator: The same creator's code has just worked with {product.operation()}"

        return result


"""
Конкретные Создатели переопределяют фабричный метод для того, чтобы изменить тип
результирующего продукта.
"""


class ConcreteCreator1(Creator):
    """
    Обратите внимание, что сигнатура метода по-прежнему использует тип
    абстрактного продукта, хотя фактически из метода возвращается конкретный
    продукт. Таким образом, Создатель может оставаться независимым от конкретных
    классов продуктов.
    """

    def factory_method(self) -> Product:
        return ConcreteProduct1()


class ConcreteCreator2(Creator):
    def factory_method(self) -> Product:
        return ConcreteProduct2()


class Product(ABC):
    """
    Интерфейс Продукта объявляет операции, которые должны выполнять все
    конкретные продукты.
    """

    @abstractmethod
    def operation(self) -> str:
        pass


"""
Конкретные Продукты предоставляют различные реализации интерфейса Продукта.
"""


class ConcreteProduct1(Product):
    def operation(self) -> str:
        return "{Result of the ConcreteProduct1}"


class ConcreteProduct2(Product):
    def operation(self) -> str:
        return "{Result of the ConcreteProduct2}"


def client_code(creator: Creator) -> None:
    """
    Клиентский код работает с экземпляром конкретного создателя, хотя и через
    его базовый интерфейс. Пока клиент продолжает работать с создателем через
    базовый интерфейс, вы можете передать ему любой подкласс создателя.
    """

    print(f"Client: I'm not aware of the creator's class, but it still works.\n"
          f"{creator.some_operation()}", end="")


if __name__ == "__main__":
    print("App: Launched with the ConcreteCreator1.")
    client_code(ConcreteCreator1())
    print("\n")

    print("App: Launched with the ConcreteCreator2.")
    client_code(ConcreteCreator2())
```

### Паттерн 6. Строитель
Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель 
даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

**Применимость**: Паттерн можно часто встретить в Python-коде, особенно там, где требуется пошаговое создание продуктов 
или конфигурация сложных объектов.
**Признаки применения паттерна**: Строителя можно узнать в классе, который имеет один создающий метод и несколько 
методов настройки создаваемого продукта. Обычно, методы настройки вызывают для удобства цепочкой (например, 
someBuilder.setValueA(1).setValueB(2).create()).

#### Применимость
- Когда вы хотите избавиться от «телескопического конструктора».
- Когда ваш код должен создавать разные представления какого-то объекта. Например, деревянные и железобетонные дома.
- Когда вам нужно собирать сложные составные объекты, например, деревья Компоновщика.

#### Преимущества
- Позволяет создавать продукты пошагово. 
- Позволяет использовать один и тот же код для создания различных продуктов. 
- Изолирует сложный код сборки продукта от его основной бизнес-логики.

#### Недостатки
- Усложняет код программы из-за введения дополнительных классов. 
- Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения 
результата.

#### Пример

```python
from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Any


class Builder(ABC):
    """
    Интерфейс Строителя объявляет создающие методы для различных частей объектов
    Продуктов.
    """

    @property
    @abstractmethod
    def product(self) -> None:
        pass

    @abstractmethod
    def produce_part_a(self) -> None:
        pass

    @abstractmethod
    def produce_part_b(self) -> None:
        pass

    @abstractmethod
    def produce_part_c(self) -> None:
        pass


class ConcreteBuilder1(Builder):
    """
    Классы Конкретного Строителя следуют интерфейсу Строителя и предоставляют
    конкретные реализации шагов построения. Ваша программа может иметь несколько
    вариантов Строителей, реализованных по-разному.
    """

    def __init__(self) -> None:
        """
        Новый экземпляр строителя должен содержать пустой объект продукта,
        который используется в дальнейшей сборке.
        """
        self.reset()

    def reset(self) -> None:
        self._product = Product1()

    @property
    def product(self) -> Product1:
        """
        Конкретные Строители должны предоставить свои собственные методы
        получения результатов. Это связано с тем, что различные типы строителей
        могут создавать совершенно разные продукты с разными интерфейсами.
        Поэтому такие методы не могут быть объявлены в базовом интерфейсе
        Строителя (по крайней мере, в статически типизированном языке
        программирования).

        Как правило, после возвращения конечного результата клиенту, экземпляр
        строителя должен быть готов к началу производства следующего продукта.
        Поэтому обычной практикой является вызов метода сброса в конце тела
        метода getProduct. Однако такое поведение не является обязательным, вы
        можете заставить своих строителей ждать явного запроса на сброс из кода
        клиента, прежде чем избавиться от предыдущего результата.
        """
        product = self._product
        self.reset()
        return product

    def produce_part_a(self) -> None:
        self._product.add("PartA1")

    def produce_part_b(self) -> None:
        self._product.add("PartB1")

    def produce_part_c(self) -> None:
        self._product.add("PartC1")


class Product1():
    """
    Имеет смысл использовать паттерн Строитель только тогда, когда ваши продукты
    достаточно сложны и требуют обширной конфигурации.

    В отличие от других порождающих паттернов, различные конкретные строители
    могут производить несвязанные продукты. Другими словами, результаты
    различных строителей могут не всегда следовать одному и тому же интерфейсу.
    """

    def __init__(self) -> None:
        self.parts = []

    def add(self, part: Any) -> None:
        self.parts.append(part)

    def list_parts(self) -> None:
        print(f"Product parts: {', '.join(self.parts)}", end="")


class Director:
    """
    Директор отвечает только за выполнение шагов построения в определённой
    последовательности. Это полезно при производстве продуктов в определённом
    порядке или особой конфигурации. Строго говоря, класс Директор необязателен,
    так как клиент может напрямую управлять строителями.
    """

    def __init__(self) -> None:
        self._builder = None

    @property
    def builder(self) -> Builder:
        return self._builder

    @builder.setter
    def builder(self, builder: Builder) -> None:
        """
        Директор работает с любым экземпляром строителя, который передаётся ему
        клиентским кодом. Таким образом, клиентский код может изменить конечный
        тип вновь собираемого продукта.
        """
        self._builder = builder

    """
    Директор может строить несколько вариаций продукта, используя одинаковые
    шаги построения.
    """

    def build_minimal_viable_product(self) -> None:
        self.builder.produce_part_a()

    def build_full_featured_product(self) -> None:
        self.builder.produce_part_a()
        self.builder.produce_part_b()
        self.builder.produce_part_c()


if __name__ == "__main__":
    """
    Клиентский код создаёт объект-строитель, передаёт его директору, а затем
    инициирует процесс построения. Конечный результат извлекается из объекта-
    строителя.
    """

    director = Director()
    builder = ConcreteBuilder1()
    director.builder = builder

    print("Standard basic product: ")
    director.build_minimal_viable_product()
    builder.product.list_parts()

    print("\n")

    print("Standard full featured product: ")
    director.build_full_featured_product()
    builder.product.list_parts()

    print("\n")

    # Помните, что паттерн Строитель можно использовать без класса Директор.
    print("Custom product: ")
    builder.produce_part_a()
    builder.produce_part_b()
    builder.product.list_parts()
```

### Паттерн 7. Адаптер

Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать 
вместе.
Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.

**Применимость**: Паттерн можно часто встретить в Python-коде, особенно там, где требуется конвертация разных типов 
данных или совместная работа классов с разными интерфейсами.
**Признаки применения паттерна**: Адаптер получает конвертируемый объект в конструкторе или через параметры своих 
методов. Методы Адаптера обычно совместимы с интерфейсом одного объекта. Они делегируют вызовы вложенному объекту, превратив перед этим параметры вызова в формат, поддерживаемый вложенным объектом.

#### Применимость
- Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
- Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности,
причём расширить суперкласс вы не можете.

#### Преимущества
- Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.

#### Недостатки
- Усложняет код программы из-за введения дополнительных классов.

#### Пример

```python
class Target:
    """
    Целевой класс объявляет интерфейс, с которым может работать клиентский код.
    """

    def request(self) -> str:
        return "Target: The default target's behavior."


class Adaptee:
    """
    Адаптируемый класс содержит некоторое полезное поведение, но его интерфейс
    несовместим с существующим клиентским кодом. Адаптируемый класс нуждается в
    некоторой доработке, прежде чем клиентский код сможет его использовать.
    """

    def specific_request(self) -> str:
        return ".eetpadA eht fo roivaheb laicepS"


class Adapter(Target, Adaptee):
    """
    Адаптер делает интерфейс Адаптируемого класса совместимым с целевым
    интерфейсом благодаря множественному наследованию.
    """

    def request(self) -> str:
        return f"Adapter: (TRANSLATED) {self.specific_request()[::-1]}"


def client_code(target: "Target") -> None:
    """
    Клиентский код поддерживает все классы, использующие интерфейс Target.
    """

    print(target.request(), end="")


if __name__ == "__main__":
    print("Client: I can work just fine with the Target objects:")
    target = Target()
    client_code(target)
    print("\n")

    adaptee = Adaptee()
    print("Client: The Adaptee class has a weird interface. "
          "See, I don't understand it:")
    print(f"Adaptee: {adaptee.specific_request()}", end="\n\n")

    print("Client: But I can work with it via the Adapter:")
    adapter = Adapter()
    client_code(adapter)
```

### Паттерн 8. Наблюдатель
Также известен как: Издатель-Подписчик, Слушатель, Observer\
**Наблюдатель** — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним 
объектам следить и реагировать на события, происходящие в других объектах.

**Применимость**: Наблюдатель можно часто встретить в Python коде, особенно там, где применяется событийная модель 
отношений между компонентами. Наблюдатель позволяет отдельным компонентам реагировать на события, происходящие в других
компонентах.\
**Признаки применения паттерна:** Наблюдатель можно определить по механизму подписки и методам оповещения, которые 
вызывают компоненты программы.

#### Применимость
- Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие 
именно объекты должны отреагировать.
- Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

#### Пример

```python
from __future__ import annotations
from abc import ABC, abstractmethod
from random import randrange
from typing import List


class Subject(ABC):
    """
    Интерфейс издателя объявляет набор методов для управления подписчиками.
    """

    @abstractmethod
    def attach(self, observer: Observer) -> None:
        """
        Присоединяет наблюдателя к издателю.
        """
        pass

    @abstractmethod
    def detach(self, observer: Observer) -> None:
        """
        Отсоединяет наблюдателя от издателя.
        """
        pass

    @abstractmethod
    def notify(self) -> None:
        """
        Уведомляет всех наблюдателей о событии.
        """
        pass


class ConcreteSubject(Subject):
    """
    Издатель владеет некоторым важным состоянием и оповещает наблюдателей о его
    изменениях.
    """

    _state: int = None
    """
    Для удобства в этой переменной хранится состояние Издателя, необходимое всем
    подписчикам.
    """

    _observers: List[Observer] = []
    """
    Список подписчиков. В реальной жизни список подписчиков может храниться в
    более подробном виде (классифицируется по типу события и т.д.)
    """

    def attach(self, observer: Observer) -> None:
        print("Subject: Attached an observer.")
        self._observers.append(observer)

    def detach(self, observer: Observer) -> None:
        self._observers.remove(observer)

    """
    Методы управления подпиской.
    """

    def notify(self) -> None:
        """
        Запуск обновления в каждом подписчике.
        """

        print("Subject: Notifying observers...")
        for observer in self._observers:
            observer.update(self)

    def some_business_logic(self) -> None:
        """
        Обычно логика подписки – только часть того, что делает Издатель.
        Издатели часто содержат некоторую важную бизнес-логику, которая
        запускает метод уведомления всякий раз, когда должно произойти что-то
        важное (или после этого).
        """

        print("\nSubject: I'm doing something important.")
        self._state = randrange(0, 10)

        print(f"Subject: My state has just changed to: {self._state}")
        self.notify()


class Observer(ABC):
    """
    Интерфейс Наблюдателя объявляет метод уведомления, который издатели
    используют для оповещения своих подписчиков.
    """

    @abstractmethod
    def update(self, subject: Subject) -> None:
        """
        Получить обновление от субъекта.
        """
        pass


"""
Конкретные Наблюдатели реагируют на обновления, выпущенные Издателем, к которому
они прикреплены.
"""


class ConcreteObserverA(Observer):
    def update(self, subject: Subject) -> None:
        if subject._state < 3:
            print("ConcreteObserverA: Reacted to the event")


class ConcreteObserverB(Observer):
    def update(self, subject: Subject) -> None:
        if subject._state == 0 or subject._state >= 2:
            print("ConcreteObserverB: Reacted to the event")


if __name__ == "__main__":
    # Клиентский код.

    subject = ConcreteSubject()

    observer_a = ConcreteObserverA()
    subject.attach(observer_a)

    observer_b = ConcreteObserverB()
    subject.attach(observer_b)

    subject.some_business_logic()
    subject.some_business_logic()

    subject.detach(observer_a)

    subject.some_business_logic()
```

### Паттерн 9. Стратегия
Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый 
из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. Программа может подменить этот объект 
другим, если требуется иной способ решения задачи.

**Применимость**: Стратегия часто используется в Python-коде, особенно там, где нужно подменять алгоритм во время 
выполнения программы. Многие примеры стратегии можно заменить простыми lambda-выражениями.\
**Признаки применения паттерна**: Класс делегирует выполнение вложенному объекту абстрактного типа или интерфейса.

#### Преимущества
- Горячая замена алгоритмов на лету. 
- Изолирует код и данные алгоритмов от остальных классов. 
- Уход от наследования к делегированию. 
- Реализует принцип открытости/закрытости.
- 
#### Недостатки
- Усложняет программу за счёт дополнительных классов. 
- Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.

#### Пример

```python
from __future__ import annotations
from abc import ABC, abstractmethod
from typing import List


class Context():
    """
    Контекст определяет интерфейс, представляющий интерес для клиентов.
    """

    def __init__(self, strategy: Strategy) -> None:
        """
        Обычно Контекст принимает стратегию через конструктор, а также
        предоставляет сеттер для её изменения во время выполнения.
        """

        self._strategy = strategy

    @property
    def strategy(self) -> Strategy:
        """
        Контекст хранит ссылку на один из объектов Стратегии. Контекст не знает
        конкретного класса стратегии. Он должен работать со всеми стратегиями
        через интерфейс Стратегии.
        """

        return self._strategy

    @strategy.setter
    def strategy(self, strategy: Strategy) -> None:
        """
        Обычно Контекст позволяет заменить объект Стратегии во время выполнения.
        """

        self._strategy = strategy

    def do_some_business_logic(self) -> None:
        """
        Вместо того, чтобы самостоятельно реализовывать множественные версии
        алгоритма, Контекст делегирует некоторую работу объекту Стратегии.
        """

        # ...

        print("Context: Sorting data using the strategy (not sure how it'll do it)")
        result = self._strategy.do_algorithm(["a", "b", "c", "d", "e"])
        print(",".join(result))

        # ...


class Strategy(ABC):
    """
    Интерфейс Стратегии объявляет операции, общие для всех поддерживаемых версий
    некоторого алгоритма.

    Контекст использует этот интерфейс для вызова алгоритма, определённого
    Конкретными Стратегиями.
    """

    @abstractmethod
    def do_algorithm(self, data: List):
        pass


"""
Конкретные Стратегии реализуют алгоритм, следуя базовому интерфейсу Стратегии.
Этот интерфейс делает их взаимозаменяемыми в Контексте.
"""


class ConcreteStrategyA(Strategy):
    def do_algorithm(self, data: List) -> List:
        return sorted(data)


class ConcreteStrategyB(Strategy):
    def do_algorithm(self, data: List) -> List:
        return reversed(sorted(data))


if __name__ == "__main__":
    # Клиентский код выбирает конкретную стратегию и передаёт её в контекст.
    # Клиент должен знать о различиях между стратегиями, чтобы сделать
    # правильный выбор.

    context = Context(ConcreteStrategyA())
    print("Client: Strategy is set to normal sorting.")
    context.do_some_business_logic()
    print()

    print("Client: Strategy is set to reverse sorting.")
    context.strategy = ConcreteStrategyB()
    context.do_some_business_logic()
```