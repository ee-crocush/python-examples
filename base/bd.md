# Базы данных, PostgreSQL

## Теория

### Что такое ACID?

ACID — это четыре свойства, которые гарантируют надежность транзакций в базах данных:

- Atomicity (Атомарность): гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.
- Consistency (Согласованность): Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты.
- Isolation (Изолированность): Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Одновременные транзакции выполняются так, как будто они работают последовательно.
- Durability (Устойчивость): После завершения транзакции ее результаты сохраняются даже в случае сбоя системы.

### Разница между типами индексов (B-Tree, GIN, GiST)

#### B-Tree (Balanced Tree)

- Стандартный тип индекса. Подходит для равенства и диапазонных запросов (=, <, >, BETWEEN).
- Используется для большинства обычных операций, например, поиска по числовым или строковым столбцам.

#### GIN (Generalized Inverted Index)

Эффективен для поиска по массивам, JSONB, полнотекстового поиска.

Пример: поиск в массиве или по строкам, содержащим слова.

#### GiST (Generalized Search Tree)

Используется для геометрических данных, поиска ближайшего соседа и полнотекстового поиска.

Пример: индексирование географических координат (с помощью PostGIS).

### Как работать с транзакциями? Что такое уровни изоляции?

#### Работа с транзакциями

Транзакция — это блок операций, которые выполняются как единое целое.

В PostgreSQL транзакции начинаются с BEGIN и завершаются COMMIT или ROLLBACK.

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

#### Уровни изоляции

Уровни изоляции определяют, как транзакции видят изменения, сделанные другими транзакциями:

- **Read Uncommitted**: На этом уровне транзакция может читать только те изменения в других параллельных транзакциях, которые уже были закоммичены. Это нас спасает от грязного чтения, но не спасает от неповторяющегося чтения и от фантомного чтения.
- **Read Committed** (по умолчанию в PostgreSQL): Видны только данные, которые были закоммичены до начала текущей операции.
- **Repeatable Read**: Этот уровень означает, что пока транзакция не завершится, никто параллельно не может изменять или удалять строки, которые транзакция уже прочитала. Т.е. данные, которые я прочитал своей транзакцией, точно никто не изменит, пока я не завершу свою транзакцию (по крайней мере, в классическом понимании этого уровня с блокировками).
  Это нас спасает и от грязного чтения, и от неповторяющегося чтения, но всё ещё мы не решаем проблему фантомного чтения. Почему? Конечно, строки, которые я уже прочитал в транзакции, никто не изменит, но никто не мешает добавлять новые строки параллельно - их мы ещё не читали, создавать их ничего не мешает.
- **Serializable**: Самый жёсткий, но самый тяжёлый для БД и медленный для обработки запросов уровень. Он блокирует любые действия, пока запущена транзакция — получается, транзакции идут строго одна за другой и максимально изолируются друг от друга. Это достигается с помощью блокировки всей таблицы от любых взаимодействий с ней, но некоторые СУБД делают менее радикально — блокируют только те строки, которые задействует текущая транзакция.

### Как оптимизировать запросы? Когда использовать индекс?

#### Оптимизация запросов

- Используйте индексы для колонок, по которым часто происходят фильтрация (WHERE, JOIN, ORDER BY, GROUP BY).
- Анализируйте запросы с помощью EXPLAIN или EXPLAIN ANALYZE, чтобы понять, как PostgreSQL их выполняет.
- Минимизируйте количество данных, загружаемых в память (LIMIT, фильтрация).
- Используйте материализованные представления для сложных агрегатов.
- Применяйте партицирование таблиц для работы с большими объемами данных.

#### Когда использовать индекс

- Если колонка часто используется в фильтрации или сортировке.
- Если выполнение запроса регулярно затрудняется полной проверкой строк (table scan).
- В случаях, когда таблица имеет большое количество строк.

### Чем отличается HAVING от WHERE?

- WHERE: Применяется для фильтрации строк перед группировкой.
- HAVING: Применяется для фильтрации уже сгруппированных данных.

Пример:

```sql
SELECT department, COUNT(_)
FROM employees
WHERE salary > 50000
GROUP BY department
HAVING COUNT(_) > 10;
```

Здесь WHERE фильтрует строки с зарплатой больше 50,000, а HAVING отбирает только те группы, где количество сотрудников больше 10.

### Как реализовать шардирование или партицирование?

#### Шардирование

- Разделение данных по физически разным серверам.
- Используется для горизонтального масштабирования.
- Шардирование можно выполнять вручную (например, с помощью логики на уровне приложения) или с использованием внешних инструментов (например, Citus).

#### Партицирование

Разделение таблицы на части внутри одного сервера.

Пример: партицирование по диапазону дат.

```sql
CREATE TABLE logs (
id SERIAL,
log_date DATE,
message TEXT
) PARTITION BY RANGE (log_date);

CREATE TABLE logs_2025_01 PARTITION OF logs
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

## Практические задачи

### SQL-запрос для получения топ-5 пользователей по активности

```sql
SELECT user_id, COUNT(*) AS activity_count
FROM user_activity
GROUP BY user_id
ORDER BY activity_count
LIMIT 5;
```

Здесь:

- user_activity — таблица с логами активности (например, действия пользователей)
- COUNT(\*) подсчитывает количество записей для каждого пользователя.
- LIMIT 5 возвращает 5 самых активных пользователей.