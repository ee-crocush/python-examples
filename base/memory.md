# Управление памяти в Python

## Основы

В Python управление памятью организовано автоматически и включает несколько ключевых механизмов:

- Подсчет ссылок (Reference Counting)
- Сборщик мусора (Garbage Collector, GC)
- Пул памяти (Memory Pooling) и аренда (Object Pooling)
- Объединение и повторное использование малых объектов

### Подсчет ссылок (Reference Counting)

В Python каждый объект хранит счетчик ссылок, который увеличивается при создании новой ссылки на объект и уменьшается
при удалении ссылки. Когда счетчик ссылок достигает нуля, объект автоматически удаляется.

Подсчет ссылок не может обработать циклические ссылки (например, когда объект ссылается сам на себя).

### Сборщик мусора (Garbage Collector, GC)

Python использует модуль gc для обнаружения циклических ссылок и удаления ненужных объектов.

### Пул памяти (Memory Pooling) и аренда (Object Pooling)

Для эффективного выделения и освобождения памяти Python использует пулы памяти и аренду небольших объектов.
Это позволяет избежать фрагментации и частых вызовов malloc/free (операции выделения памяти в C).

Основные механизмы:

- Объекты до 512 байт управляются через аренду (pymalloc)
- Объекты больше 512 байт выделяются напрямую через malloc()
- Выделенная, но неиспользуемая память не сразу возвращается ОС

### Объединение и повторное использование малых объектов

Python оптимизирует создание неизменяемых объектов (int, str, tuple) и часто переиспользует их.

### Выводы

1. Python использует автоматическое управление памятью, поэтому не нужно вручную выделять и освобождать память.
2. Основной механизм — подсчет ссылок, но он не решает проблему циклических ссылок.
3. Сборщик мусора (GC) работает по поколенческой модели и устраняет циклические ссылки.
4. Пулы памяти (pymalloc) оптимизируют работу с небольшими объектами, предотвращая фрагментацию.
5. Кеширование и повторное использование объектов повышает производительность, но не всегда очевидно.

## Внутреннее устройства запуска кода

Когда мы пишем код на Python и запускам его, происходит несколько этапов:

1. Загрузка интерпретатора и запуск процесса
2. Компиляция в байт-код (bytecode)
3. Исполнение байт-кода в виртуальной машине Python (CPython VM)
4. Управление памятью и выполнение кода

### 1. Загрузка интерпретатора и запуск процесса

При запуске программы происходит следующее:

- Система создает новый процесс Python.
- Загружается интерпретатор CPython, который начнет обработку файла py.

Если запустить python без аргументов, откроется интерактивная среда (REPL), где можно вводить команды построчно.

### 2. Компиляция в байт-код (Bytecode Compilation)

Python — интерпретируемый язык, но код не выполняется напрямую, а сначала компилируется в байт-код.

Когда ты запускаем py файл, вот что делает интерпретатор:

- Читает файл и анализирует его синтаксис.
- Преобразует код в абстрактное синтаксическое дерево (AST).
- Генерирует байт-код — инструкции для Python Virtual Machine (PVM).

Пример:

```python
print("Hello, World!")
```

Этот код компилируется в байт-код:

```sh
LOAD_GLOBAL 0 (print)
LOAD_CONST 0 ('Hello, World!')
CALL_FUNCTION 1
POP_TOP
```

Байт-код хранится в файлах .pyc в директории __pycache__, чтобы при следующем запуске ускорить загрузку.

Можно скомпилировать код вручную:

```python
import py_compile

py_compile.compile("script.py")
```

Или посмотреть байт-код:

```python
import dis

dis.dis("print('Hello')")
```

### 3. Исполнение байт-кода в виртуальной машине Python (PVM)

После компиляции в байт-код Python Virtual Machine (PVM) начинает выполнять инструкции.

PVM представляет собой интерпретатор байт-кода, который выполняет команды пошагово.

Пример стека вызовов (stack-based execution):

```python
a = 3
b = 5
c = a + b
```

В байт-коде это выглядит так:

```sh
LOAD_CONST 0 (3)  # Загружаем 3 в стек
STORE_NAME 0 (a)  # Сохраняем в переменную a
LOAD_CONST 1 (5)  # Загружаем 5 в стек
STORE_NAME 1 (b)  # Сохраняем в переменную b
LOAD_NAME 0 (a)   # Загружаем a в стек
LOAD_NAME 1 (b)   # Загружаем b в стек
BINARY_ADD # Складываем (3 + 5)
STORE_NAME 2 (c)  # Сохраняем результат в c
```

PVM читает байт-код инструкцию за инструкцией, выполняя команды на виртуальном стеке.

### 4. Управление памятью и выполнение кода

Во время выполнения кода:

- Создаются объекты в памяти (числа, строки, списки).
- Python управляет памятью через подсчет ссылок и сборщик мусора.
- Глобальные и локальные переменные хранятся в таблицах символов.
- Функции и модули загружаются в пространство имен (namespace).

### Выводы

- Python не интерпретирует код напрямую, а компилирует его в байт-код перед выполнением.
- Байт-код исполняется в виртуальной машине CPython, которая управляет стеком и памятью.
- Python управляет памятью автоматически с помощью подсчета ссылок и сборщика мусора.
- Модули и объекты кэшируются, чтобы ускорить повторные запуски.

## Организация памяти

В Python данные хранятся в двух основных областях памяти:

- **Стек (Stack)** — хранит ссылки на объекты, локальные переменные и вызовы функций.
- **Куча (Heap)** — хранит реальные объекты (числа, строки, списки, словари, функции и т. д.)

## 1. Как Python хранит переменные и функции?

Когда мы пишем код, Python управляет памятью следующим образом:

- Переменные создаются в стеке, но их значения (объекты) хранятся в куче.
- Функции и классы тоже хранятся в куче, а ссылки на них — в стеке.
- Глобальные переменные и модули хранятся в специальной области памяти.

Пример:

```python
x = 42
y = x
z = [1, 2, 3]
```

Что здесь происходит?

- Число 42 создается в куче.
- В стеке создается переменная x, которая ссылается на объект 42 в куче.
- Переменная y получает ту же ссылку, поэтому оба указывают на один объект.
- Список [1, 2, 3] создается в куче, а переменная z в стеке указывает на него.

### 2. Как передаются аргументы в Python?

Python передает аргументы по ссылке, но есть важный нюанс:

- Неизменяемые объекты (int, str, tuple) — передаются по ссылке, но при изменении создается новый объект.
- Изменяемые объекты (list, dict, set) — передаются по ссылке, и изменения затрагивают оригинальный объект.