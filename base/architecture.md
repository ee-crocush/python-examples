# Архитектура

## 1. Монолитная архитектура

### Описание

- Все модули и компоненты приложения объединены в один код и исполняются как единое целое.
- Пример: классическое приложение Django.

### Плюсы

- Простота разработки и деплоя.
- Легче отлаживать на начальных этапах.
- Нет проблем с сетевой задержкой.

### Минусы

- **Сложность масштабирования**: весь код масштабируется как единый блок.
- **Неповоротливость**: добавление новых функций или изменение старых требует осторожности.

### Когда применять

- Небольшие проекты или стартапы.
- Когда нужна быстрая разработка MVP (минимального жизнеспособного продукта).

## 2. Микросервисная архитектура

### Описание

Приложение делится на независимые сервисы, каждый из которых отвечает за свою задачу (например, управление пользователями, заказы, уведомления).

### Плюсы

- **Локализованная ответственность**: каждый сервис выполняет свою задачу.
- **Масштабируемость**: можно масштабировать только те сервисы, которые требуют ресурсов.
- **Технологическая гибкость**: разные сервисы могут использовать разные технологии.

### Минусы

- Сложность взаимодействия между сервисами (например, gRPC или REST).
- Повышенные затраты на DevOps и мониторинг.
- Сложность согласования данных между сервисами.

### Когда применять

- Большие проекты с высокими нагрузками.
- Разделение разработки между командами.
- Если проект будет долго развиваться и расширяться.

## 3. Событийно-ориентированная архитектура (Event-Driven Architecture)

### Описание

Сервисы или модули взаимодействуют посредством событий, которые публикуются и обрабатываются другими частями системы.

### Плюсы

- **Асинхронность**: модули могут работать независимо друг от друга.
- **Масштабируемость**: легко добавлять новые обработчики событий.
- **Устойчивость**: сбой одного модуля не нарушает работу других.

### Минусы

- Сложность тестирования и отладки.
- Нужен надежный брокер сообщений (RabbitMQ, Kafka).
- Возможны задержки в обработке событий.

### Когда применять

- Высоконагруженные системы, требующие асинхронной обработки.
- Сложные бизнес-процессы с большим количеством шагов.
- Проекты, где нужно легко добавлять новые модули.

## 4. Чистая архитектура (Clean Architecture)

### Описание

- Приложение делится на слои, причем зависимость всегда направлена внутрь: внешний мир зависит от внутреннего, а не наоборот.
- Центральный слой — это доменная логика.

### Плюсы

- Упрощение тестирования.
- Гибкость и адаптивность.
- Независимость от фреймворков и баз данных.

### Минусы

- Увеличение сложности на старте.
- Трудно применять для небольших проектов.

### Когда применять

- Долгосрочные проекты с большими требованиями к качеству кода.
- Если проект может сильно измениться в будущем.

## 5. Луковая архитектура (Onion Architecture)

### Описание

Очень похожа на чистую архитектуру, но с четким акцентом на доменную модель в центре.

### Плюсы

- Изоляция домена от инфраструктуры.
- Хорошо структурированная кодовая база.

### Минусы

- Сложность начального проектирования.
- Для небольших проектов кажется "перегруженной".

### Когда применять

- Проекты с четко выраженной доменной областью.
- Нужна долгосрочная поддержка кода.

## 6. Domain-Driven Design (DDD, предметно-ориентированное проектирование)

### Описание

Архитектура строится вокруг доменной модели. Это больше подход к проектированию, чем конкретная архитектура, но часто используется с микросервисами.

### Плюсы

- Фокус на бизнес-логике.
- Ясная и понятная модель домена.

### Минусы

- Требует высокого уровня навыков у разработчиков.
- Увеличение сложности на старте.

### Когда применять

- Сложные бизнес-домены.
- Проекты с большим количеством бизнес-правил.

## Сравнение

| Архитектура          | Простота разработки | Масштабируемость | Подходит для сложных доменов | Затраты DevOps | Независимость компонентов |
| -------------------- | ------------------- | ---------------- | ---------------------------- | -------------- | ------------------------- |
| Монолит              | +                   | -                | -                            | +              | -                         |
| Микросервисы         | -                   | +                | +                            | -              | +                         |
| Событийная           | -                   | +                | +                            | -              | +                         |
| Чистая архитектура   | -                   | +                | +                            | +/-            | +                         |
| Луковая архитектура  | -                   | +                | +                            | +/-            | +                         |
| Domain-Driven Design | -                   | +/-              | +                            | +/-            | +                         |

### Сравнение слоев

| Архитектура         | Основные слои                                     | Особенности                 |
|---------------------|---------------------------------------------------|-----------------------------|
| Монолит             | Презентация, Бизнес-логика, Данные                | Простая структура.          |
| Микросервисы        | API, Сервис, Данные, Коммуникация                 | Изоляция между сервисами.   |
| Событийная          | Публикация, Обработка, Логика, Данные             | Асинхронное взаимодействие. |
| Чистая архитектура  | Entities, Use Cases, Adapters, Drivers            | Зависимость внутрь.         |
| Луковая архитектура | Core, Application, Infrastructure                 | Четкий акцент на домен.     |
| DDD                 | Domain, Application, Infrastructure, Presentation | Фокус на доменной модели.   |

### Вывод

- Если проект небольшой и требует быстрой разработки — лучше начинать с монолита.
- Для сложных, высоконагруженных систем с распределенной командой — подойдут микросервисы.
- Если важна асинхронность и гибкость — выбирай событийную архитектуру.
- Для долгосрочных проектов с акцентом на качество кода и сложный бизнес-домен — чистая архитектура или DDD.