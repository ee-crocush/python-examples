# ООП

## База

### Классы и объекты

- Класс — это шаблон или чертеж для создания объектов.
- Объект — экземпляр класса.

```python
# Определение класса
class Animal:
    def __init__(self, name):  # Конструктор
        self.name = name

    def speak(self):
        print(f"{self.name} издает звук.")

# Создание объекта
dog = Animal("Собака")
dog.speak()  # Собака издает звук.
```

### Наследование

Позволяет создавать новый класс, унаследовав методы и свойства существующего.

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} издает звук.")

# Наследуемый класс
class Dog(Animal):
    def speak(self):  # Переопределение метода
        print(f"{self.name} лает.")

class Cat(Animal):
    def speak(self):  # Переопределение метода
        print(f"{self.name} мяукает.")

dog = Dog("Шарик")
cat = Cat("Мурка")
dog.speak()  # Шарик лает.
cat.speak()  # Мурка мяукает.
```

### Инкапсуляция

Инкапсуляция скрывает внутренние детали объекта с помощью приватных атрибутов и методов.
Приватные атрибуты/методы: начинаются с \_ (protected) или \_\_ (private).

```python
class BankAccount:
    def **init**(self, balance):
        self.__balance = balance # Приватный атрибут

    def deposit(self, amount):
        self.__balance += amount

    def __str__(self):
        return f"Баланс: {self.__balance}"

account = BankAccount(1000)
account.deposit(500)
print(account) # Баланс: 1500

# Ошибка при доступе к приватному атрибуту

# print(account.__balance) # AttributeError
```

### Полиморфизм

Один интерфейс может быть реализован по-разному в разных классах.

```python
class Shape:
    def draw(self):
        pass

class Circle(Shape):
    def draw(self):
        print("Рисуем круг.")

class Square(Shape):
    def draw(self):
        print("Рисуем квадрат.")

def render_shape(shape):
shape.draw() # Вызов метода у разных объектов

circle = Circle()
square = Square()
render_shape(circle) # Рисуем круг.
render_shape(square) # Рисуем квадрат.
```

### Абстракция

Скрывает детали реализации, оставляя только основные функции. В Python это достигается
с помощью абстрактных классов (модуль abc).

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

rect = Rectangle(5, 10)
print(rect.area()) # 50
print(rect.perimeter()) # 30
```

### Геттеры и сеттеры

- Геттеры: методы для получения значения атрибута.
- Сеттеры: методы для изменения значения атрибута.

Python позволяет использовать встроенные механизмы для создания геттеров и сеттеров через декоратор @property.

Почему нужны геттеры и сеттеры?

- Контроль доступа к данным: можно проверять, валидировать или обрабатывать данные перед их чтением/изменением.
- Инкапсуляция: позволяет скрыть детали реализации.
- Логика управления атрибутами: например, автоматическая конвертация значений.

В Python более удобный способ создания геттеров и сеттеров — через декораторы @property.

```python
class Person:
    def __init__(self, name):
        self._name = name # Приватный атрибут

    @property
    def name(self):  # Геттер
        return self._name

    @name.setter
    def name(self, value):  # Сеттер
        if not value:
            raise ValueError("Имя не может быть пустым!")
        self._name = value

person = Person("Иван")
print(person.name) # Иван (геттер)
person.name = "Мария" # Сеттер
print(person.name) # Мария
```

### Примеры из жизни

- Инкапсуляция: Банковский аккаунт скрывает баланс (его нельзя изменять напрямую),
  но предоставляет методы пополнения и снятия денег.
- Наследование: Веб-приложение имеет базовый класс User, от которого наследуются классы AdminUser, RegularUser.
- Полиморфизм: Логгер может выводить сообщения в консоль, файл или удаленный сервер — у всех разный способ работы, но единый интерфейс.
- Абстракция: Система оплаты: пользователь видит только интерфейс оплаты, но не знает, как происходит обработка транзакции внутри.

## SOLID

SOLID — это набор из пяти принципов объектно-ориентированного программирования (ООП), которые помогают создавать более гибкий, поддерживаемый и масштабируемый код. Принципы были предложены Робертом Мартином (Robert C. Martin), также известным как Uncle Bob.

### S — Single Responsibility Principle (Принцип единственной ответственности)

У класса должна быть только одна причина для изменения. Другими словами, класс должен выполнять только одну задачу.

Почему это важно?

Если класс выполняет несколько задач, изменения в одной из них могут повлиять на другие. Это усложняет сопровождение и тестирование.

### O — Open/Closed Principle (Принцип открытости/закрытости)

Классы должны быть открыты для расширения, но закрыты для изменения. Другими словами, добавление новой функциональности не должно требовать изменения существующего кода.

Почему это важно?

Если код приходится часто менять, возрастает риск сломать существующую функциональность.

### L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)

Объекты наследующих классов должны быть взаимозаменяемы с объектами базового класса без нарушения логики программы.

Почему это важно?

Если подклассы не полностью соответствуют поведению базового класса, это может привести к неожиданным ошибкам.

### I — Interface Segregation Principle (Принцип разделения интерфейса)

Классы не должны зависеть от интерфейсов, которые они не используют.

Почему это важно?

Если класс вынужден реализовывать ненужные методы, это делает его сложнее и увеличивает риск ошибок.

### D — Dependency Inversion Principle (Принцип инверсии зависимостей)

Классы должны зависеть от абстракций, а не от конкретных реализаций.

Почему это важно?

Если классы зависят от конкретных реализаций, любые изменения в этих реализациях потребуют изменений во всех зависимых классах.

### Как применять SOLID?

- S: Каждый класс/модуль отвечает за одну задачу.
- O: Легче добавлять новую функциональность, чем менять старую.
- L: Убедись, что наследники могут использоваться вместо базового класса.
- I: Не нагружай классы лишними обязанностями.
- D: Всегда разрабатывай систему вокруг абстракций, а не конкретных реализаций.
