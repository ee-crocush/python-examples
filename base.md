## 1. Базовые знания Python

### 1.1 Mutable/Immutable типы данных

- Mutable (изменяемые): Можно изменять объект без создания нового. Примеры: list, dict, set.
- Immutable (неизменяемые): Любое изменение приводит к созданию нового объекта. Примеры: int, float, str, tuple.

### 1.2 Разница между is и ==

- is проверяет, являются ли два объекта одним и тем же в памяти.
- == проверяет, имеют ли два объекта одинаковое значение.

### 1.3 @staticmethod, @classmethod, обычные методы

- Обычные методы принимают ссылку на экземпляр класса как первый аргумент (self).
- @classmethod принимает класс как первый аргумент (cls).
- @staticmethod не принимает ни self, ни cls.

### 1.4 Работа with и менеджеров контекста

with используется для автоматического управления ресурсами (например, файлы, соединения).
Менеджеры контекста определяются через методы **enter** и **exit**.

### 1.5 Сборщик мусора в Python

Python использует автоматическую сборку мусора для управления памятью. Основные принципы:

- Объект удаляется, когда на него нет ссылок.
- Используется подсчёт ссылок и сборка циклических ссылок.

### 1.6 Работа с исключениями

Исключения обрабатываются с помощью блока try-except.

### 1.7 Коллекции

- list: изменяемый, упорядоченный.
- tuple: неизменяемый, упорядоченный.
- set: изменяемый, неупорядоченный, уникальные элементы.
- frozenset: неизменяемый set.
- dict: изменяемый, упорядоченный (Python 3.7+).

### 1.8 ООП

#### Классы и объекты

- Класс — это шаблон или чертеж для создания объектов.
- Объект — экземпляр класса.

```python
# Определение класса
class Animal:
    def __init__(self, name):  # Конструктор
        self.name = name

    def speak(self):
        print(f"{self.name} издает звук.")

# Создание объекта
dog = Animal("Собака")
dog.speak()  # Собака издает звук.
```

#### 2. Наследование

Позволяет создавать новый класс, унаследовав методы и свойства существующего.

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} издает звук.")

# Наследуемый класс
class Dog(Animal):
    def speak(self):  # Переопределение метода
        print(f"{self.name} лает.")

class Cat(Animal):
    def speak(self):  # Переопределение метода
        print(f"{self.name} мяукает.")

dog = Dog("Шарик")
cat = Cat("Мурка")
dog.speak()  # Шарик лает.
cat.speak()  # Мурка мяукает.
```

#### 3. Инкапсуляция

Инкапсуляция скрывает внутренние детали объекта с помощью приватных атрибутов и методов.
Приватные атрибуты/методы: начинаются с \_ (protected) или \_\_ (private).

```python
class BankAccount:
    def **init**(self, balance):
        self.__balance = balance # Приватный атрибут

    def deposit(self, amount):
        self.__balance += amount

    def __str__(self):
        return f"Баланс: {self.__balance}"

account = BankAccount(1000)
account.deposit(500)
print(account) # Баланс: 1500

# Ошибка при доступе к приватному атрибуту

# print(account.__balance) # AttributeError
```

#### 4. Полиморфизм

Один интерфейс может быть реализован по-разному в разных классах.

```python
class Shape:
    def draw(self):
        pass

class Circle(Shape):
    def draw(self):
        print("Рисуем круг.")

class Square(Shape):
    def draw(self):
        print("Рисуем квадрат.")

def render_shape(shape):
shape.draw() # Вызов метода у разных объектов

circle = Circle()
square = Square()
render_shape(circle) # Рисуем круг.
render_shape(square) # Рисуем квадрат.
```

#### 5. Абстракция

Скрывает детали реализации, оставляя только основные функции. В Python это достигается
с помощью абстрактных классов (модуль abc).

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

rect = Rectangle(5, 10)
print(rect.area()) # 50
print(rect.perimeter()) # 30
```

#### 6. Геттеры и сеттеры

- Геттеры: методы для получения значения атрибута.
- Сеттеры: методы для изменения значения атрибута.

Python позволяет использовать встроенные механизмы для создания геттеров и сеттеров через декоратор @property.

Почему нужны геттеры и сеттеры?

- Контроль доступа к данным: можно проверять, валидировать или обрабатывать данные перед их чтением/изменением.
- Инкапсуляция: позволяет скрыть детали реализации.
- Логика управления атрибутами: например, автоматическая конвертация значений.

В Python более удобный способ создания геттеров и сеттеров — через декораторы @property.

```python
class Person:
    def __init__(self, name):
        self._name = name # Приватный атрибут

    @property
    def name(self):  # Геттер
        return self._name

    @name.setter
    def name(self, value):  # Сеттер
        if not value:
            raise ValueError("Имя не может быть пустым!")
        self._name = value

person = Person("Иван")
print(person.name) # Иван (геттер)
person.name = "Мария" # Сеттер
print(person.name) # Мария

#### 7. Примеры из жизни

- Инкапсуляция: Банковский аккаунт скрывает баланс (его нельзя изменять напрямую),
но предоставляет методы пополнения и снятия денег.
- Наследование: Веб-приложение имеет базовый класс User, от которого наследуются классы AdminUser, RegularUser.
- Полиморфизм: Логгер может выводить сообщения в консоль, файл или удаленный сервер — у всех разный способ работы, но единый интерфейс.
- Абстракция: Система оплаты: пользователь видит только интерфейс оплаты, но не знает, как происходит обработка транзакции внутри.

### 1.9 Что такое MRO?

MRO (Method Resolution Order) — это порядок, в котором Python ищет методы и атрибуты в классе и его родителях при обращении к ним. Это важно в ситуациях с множественным наследованием, чтобы избежать неоднозначностей и избыточного вызова одного и того же метода.

Python использует алгоритм C3-линеаризации для определения порядка. Этот алгоритм был введен, чтобы сделать порядок поиска методов логичным и предсказуемым.

Как работает MRO?
Когда вы вызываете метод (например, obj.method()), Python:

- Ищет метод сначала в самом классе объекта.
- Затем проходит по родительским классам в порядке, определенном MRO.
- Если метод найден, он выполняется. Если нет, Python поднимает исключение AttributeError.
```
