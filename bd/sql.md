# Базы данных, PostgreSQL

## Теория

### Что такое ACID?

ACID — это четыре свойства, которые гарантируют надежность транзакций в базах данных:

- Atomicity (Атомарность): гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем.
  Не допускаются промежуточные состояния.
- Consistency (Согласованность): Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои
  результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению
  фиксирует
  только допустимые результаты.
- Isolation (Изолированность): Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на
  её результат. Одновременные транзакции выполняются так, как будто они работают последовательно.
- Durability (Устойчивость): После завершения транзакции ее результаты сохраняются даже в случае сбоя системы.

### Разница между типами индексов (B-Tree, GIN, GiST)

#### B-Tree (Balanced Tree)

- Стандартный тип индекса. Подходит для равенства и диапазонных запросов (=, <, >, BETWEEN).
- Используется для большинства обычных операций, например, поиска по числовым или строковым столбцам.

#### GIN (Generalized Inverted Index)

Эффективен для поиска по массивам, JSONB, полнотекстового поиска.

Пример: поиск в массиве или по строкам, содержащим слова.

#### GiST (Generalized Search Tree)

Используется для геометрических данных, поиска ближайшего соседа и полнотекстового поиска.

Пример: индексирование географических координат (с помощью PostGIS).

### Как работать с транзакциями? Что такое уровни изоляции?

#### Работа с транзакциями

Транзакция — это блок операций, которые выполняются как единое целое.

В PostgreSQL транзакции начинаются с BEGIN и завершаются COMMIT или ROLLBACK.

```sql
BEGIN;
UPDATE accounts
SET balance = balance - 100
WHERE id = 1;
UPDATE accounts
SET balance = balance + 100
WHERE id = 2;
COMMIT;
```

#### Уровни изоляции

Уровни изоляции определяют, как транзакции видят изменения, сделанные другими транзакциями:

- **Read Uncommitted**: Из названия очевидно, что можно читать даже те данные, которые еще не были закомичены.
- **Read Committed** (по умолчанию в PostgreSQL): Видны только данные, которые были закоммичены до начала текущей
  операции.
- **Repeatable Read**: Этот уровень означает, что пока транзакция не завершится, никто параллельно не может изменять или
  удалять строки, которые транзакция уже прочитала. Т.е. данные, которые я прочитал своей транзакцией, точно никто не
  изменит, пока я не завершу свою транзакцию (по крайней мере, в классическом понимании этого уровня с блокировками).
  Это нас спасает и от грязного чтения, и от неповторяющегося чтения, но всё ещё мы не решаем проблему фантомного
  чтения. Почему? Конечно, строки, которые я уже прочитал в транзакции, никто не изменит, но никто не мешает добавлять
  новые строки параллельно - их мы ещё не читали, создавать их ничего не мешает.
- **Serializable**: Самый жёсткий, но самый тяжёлый для БД и медленный для обработки запросов уровень. Он блокирует
  любые действия, пока запущена транзакция — получается, транзакции идут строго одна за другой и максимально изолируются
  друг от друга. Это достигается с помощью блокировки всей таблицы от любых взаимодействий с ней, но некоторые СУБД
  делают менее радикально — блокируют только те строки, которые задействует текущая транзакция.

### Как оптимизировать запросы? Когда использовать индекс?

#### Оптимизация запросов

- Используйте индексы для колонок, по которым часто происходят фильтрация (WHERE, JOIN, ORDER BY, GROUP BY).
- Анализируйте запросы с помощью EXPLAIN или EXPLAIN ANALYZE, чтобы понять, как PostgreSQL их выполняет.
- Минимизируйте количество данных, загружаемых в память (LIMIT, фильтрация).
- Используйте материализованные представления для сложных агрегатов.
- Применяйте партицирование таблиц для работы с большими объемами данных.

Пример анализа запроса:

```sql
EXPLAIN
ANALYZE
SELECT *
FROM users
WHERE email = 'test@example.com';
```

Вывод покажет:

- Использует ли запрос индекс (Index Scan вместо Seq Scan).
- Время выполнения запроса.
- Оценку стоимости запроса.

#### Когда использовать индекс

- Если колонка часто используется в фильтрации или сортировке.
- Если выполнение запроса регулярно затрудняется полной проверкой строк (table scan).
- В случаях, когда таблица имеет большое количество строк.

### Чем отличается HAVING от WHERE?

- WHERE: Применяется для фильтрации строк перед группировкой.
- HAVING: Применяется для фильтрации уже сгруппированных данных. При этом HAVING можно использовать и для простых полей

Пример:

```sql
SELECT department, COUNT(_)
FROM employees
WHERE salary > 50000
GROUP BY department
HAVING COUNT(_) > 10
   and department LIKE '%Администрация%';
```

Здесь WHERE фильтрует строки с зарплатой больше 50,000, а HAVING отбирает только те группы, где количество сотрудников
больше 10 и в названии отдела присутствует "Администрация".

### Как реализовать шардирование или партицирование?

#### Шардирование

- Разделение данных по физически разным серверам.
- Используется для горизонтального масштабирования.
- Шардирование можно выполнять вручную (например, с помощью логики на уровне приложения) или с использованием внешних
  инструментов (например, Citus).

Стратегии:

- По диапазону (например, по ID или дате).
- По хешу (равномерное распределение по узлам).

Пример: разнесение пользователей по разным базам данных в зависимости от их региона.

#### Партицирование

Разделение таблицы на части внутри одного сервера.

Пример: партицирование по диапазону дат.

```sql
CREATE TABLE logs
(
    id       SERIAL,
    log_date DATE,
    message  TEXT
) PARTITION BY RANGE (log_date);

CREATE TABLE logs_2025_01 PARTITION OF logs
    FOR VALUES FROM
(
    '2025-01-01'
) TO
(
    '2025-02-01'
);
```

## Практические задачи

### 1. SQL-запрос для получения топ-5 пользователей по активности

```sql
SELECT user_id, COUNT(*) AS activity_count
FROM user_activity
GROUP BY user_id
ORDER BY activity_count LIMIT 5;
```

Здесь:

- user_activity — таблица с логами активности (например, действия пользователей)
- COUNT(\*) подсчитывает количество записей для каждого пользователя.
- LIMIT 5 возвращает 5 самых активных пользователей.

### 2. Использование CTE для упрощения сложных запросов

```sql
WITH top_users AS (SELECT user_id, COUNT(*) AS activity_count
                   FROM user_activity
                   GROUP BY user_id
                   ORDER BY activity_count DESC
    LIMIT 5
    )
SELECT u.username, t.activity_count
FROM top_users t
         JOIN users u ON u.id = t.user_id;
```

### 3. Использование оконных функций

Вывести среднюю зарплату по отделу и разницу с зарплатой сотрудника:

```sql
SELECT employee_id,
       department_id,
       salary,
       AVG(salary) OVER (PARTITION BY department_id) AS avg_salary, salary - AVG(salary) OVER (PARTITION BY department_id) AS salary_diff
FROM employees;
```

### 4. Найти пользователей, которые зарегистрировались в последние 7 дней

```sql
SELECT *
FROM users
WHERE created_at >= NOW() - INTERVAL '7 days';
```

5. Денормализация с помощью материализованных представлений

```sql
CREATE
MATERIALIZED VIEW top_users AS
SELECT user_id, COUNT(*) AS activity_count
FROM user_activity
GROUP BY user_id
ORDER BY activity_count DESC LIMIT 5;

REFRESH
MATERIALIZED VIEW top_users;
```